<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fire&#39;s Blog</title>
  
  <subtitle>念念不忘，必有回响</subtitle>
  <link href="https://i-fire.top/atom.xml" rel="self"/>
  
  <link href="https://i-fire.top/"/>
  <updated>2021-02-23T11:08:57.661Z</updated>
  <id>https://i-fire.top/</id>
  
  <author>
    <name>烟火小兽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双向链表</title>
    <link href="https://i-fire.top/post/twoWayLinkedList.html"/>
    <id>https://i-fire.top/post/twoWayLinkedList.html</id>
    <published>2021-02-23T11:04:37.000Z</published>
    <updated>2021-02-23T11:08:57.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>在之前学习的的链表中，无论是静态链表或者是动态链表，在他们的每一个节点中值包含一个指针（游标），而且指针都是同一个指向后继节点，通常称这类链表为单向链表（或单链表）。，使用这些单链表虽然可以解决逻辑关系为<strong>一对一</strong>数据的存储问题，但是在解决某些特殊问题的时候，这些链表并不是效率最优的存储结构，比如说，在某些情况下需要大量的查找某节点的前驱节点，使用单链表无疑是很繁琐的，因为单链表更适合的是<strong>从前往后找</strong>并，<strong>从后往前找</strong>并不是他的强项！<br>对于逆向查找（从后往前进行查找）相关的问题，我们可以使用<strong>双向链表</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>双向链表，简称双链表。从名字上理解双向链表，即链表是 “双向” 的<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210223082035.png"></p><p>所谓双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要，可以为最后一个节点再设置一个“头指针”。<br>根据上图可知，双向链表中各个节点包含以下3部分信息</p><ul><li>指针域：指向当前节点的前驱节点</li><li>数据域：存储数据元素</li><li>指针域：用于指向当前节点的直接后继节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210223082258.png"></p><h3 id="双向链表的代码实现"><a href="#双向链表的代码实现" class="headerlink" title="双向链表的代码实现"></a>双向链表的代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="comment">//定义双向链表的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">twoWayLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twoWayLinkedList</span>* <span class="title">pre</span>;</span><span class="comment">//当前节点的前驱节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twoWayLinkedList</span>* <span class="title">next</span>;</span><span class="comment">//当前节点的后继节点指针</span></span><br><span class="line">&#125; tWLLNode;</span><br><span class="line"><span class="function">tWLLNode* <span class="title">initTwoWayLinkedList</span><span class="params">()</span></span>;<span class="comment">//获取一个双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTwoWayLinkedListEmpty</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//判断双向链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addELeTwoWayLinkedList</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在双向链表的头部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListTail</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在双向链表的尾部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在中间添加一个元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//遍历双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTwoWayLinkedListLength</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//获取双向链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleInTwoWayLinkedListByindex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index获取节点的值并返回，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//销毁整个双向链表包括头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListHead</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//删除双向链表的首元节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListTail</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//删除双向链表尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index删除节点,index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">tWLLNode* head = initTwoWayLinkedList();</span><br><span class="line">addEleTwoLinkedListTail(head, <span class="number">19</span>);</span><br><span class="line">addELeTwoWayLinkedList(head, <span class="number">1</span>);</span><br><span class="line">addELeTwoWayLinkedList(head, <span class="number">2</span>);</span><br><span class="line">addEleTwoLinkedListTail(head, <span class="number">190</span>);</span><br><span class="line">addELeTwoWayLinkedList(head, <span class="number">3</span>);</span><br><span class="line">addEleTwoLinkedListByIndex(head, <span class="number">2</span>, <span class="number">89</span>);</span><br><span class="line">deleteTwoWayLinkedListHead(head);</span><br><span class="line">deleteTwoWayLinkedListByIndex(head, <span class="number">5</span>);</span><br><span class="line">outTwoWayLinkedList(head);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表是否为空==========================&gt;%d\n&quot;</span>, isTwoWayLinkedListEmpty(head));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表的长度是=======================&gt;%d\n&quot;</span>, getTwoWayLinkedListLength(head));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表中第199个元素是=============&gt;%d\n&quot;</span>, getEleInTwoWayLinkedListByindex(head, <span class="number">199</span>));</span><br><span class="line"><span class="comment">//destoryTwoWayLinkedList(head);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tWLLNode* <span class="title">initTwoWayLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tWLLNode* head = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));<span class="comment">//构造出双向链表的头节点，有了这个头节点可以更加方便的处理双向链表</span></span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建双向链表失败=================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTwoWayLinkedListEmpty</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断双向链表是否为空失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addELeTwoWayLinkedList</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在双向链表头插入元素失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表插入元素失败====================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line">tWLLNode* temp = head-&gt;next;<span class="comment">//原来双向链表中的第一个节点</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;<span class="comment">//说明是第一次添加节点</span></span><br><span class="line">p-&gt;pre = head;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;pre = p;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">p-&gt;pre = head;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历双向链表失败=====================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向循环链表中第%d个元素是=============&gt;%d\n&quot;</span>, i, p-&gt;data);</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListTail</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在双向链表的尾部添加元素失败==============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;<span class="comment">//第一次添加节点，直接调用头添加</span></span><br><span class="line">addELeTwoWayLinkedList(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* temp = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表尾部添加元素失败================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;pre = p;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index插入元素失败==============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//直接调用头添加</span></span><br><span class="line">addELeTwoWayLinkedList(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p &amp;&amp; p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != i || p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index插入元素失败================&gt;元素不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* temp = p-&gt;pre;<span class="comment">//当前节点的前一个节点</span></span><br><span class="line">tWLLNode* node = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));</span><br><span class="line"><span class="keyword">if</span> (!node) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index添加元素失败================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">temp-&gt;next = node;</span><br><span class="line">node-&gt;pre = temp;</span><br><span class="line">node-&gt;next = p;</span><br><span class="line">p-&gt;pre = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTwoWayLinkedListLength</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取双向链表长度失败================参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleInTwoWayLinkedListByindex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index获取双向链表的值失败================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; i &lt; index) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> || index != i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index获取节点值失败=======================&gt;节点不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁双向链表失败===========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line">tWLLNode* temp;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">temp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListHead</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除首元节点失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;<span class="comment">//判断是不是只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;pre = head;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListTail</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除双向链表尾结点失败=================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;<span class="comment">//说明只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* temp = p-&gt;pre;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span> || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除元素失败========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">deleteTwoWayLinkedListHead(head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除节点错误=====================&gt;节点不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//说明是最后一个节点</span></span><br><span class="line">p-&gt;pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next-&gt;pre = p-&gt;pre;</span><br><span class="line">p-&gt;pre-&gt;next = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，双向链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="双向链表" scheme="https://i-fire.top/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>单向循环链表</title>
    <link href="https://i-fire.top/post/circularLinkedList.html"/>
    <id>https://i-fire.top/post/circularLinkedList.html</id>
    <published>2021-02-22T07:44:15.000Z</published>
    <updated>2021-02-22T07:46:57.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>循环链表是一种头尾相接的链表，他的最后一个指针域指向头节点，形成一个环<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210221083642.png"></p><p><strong>注意：</strong>虽然循环链表成环状，，但是本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等等，循环链表和普通的链表相比，唯一不同的就是循环链表首尾相连（尾结点的指针域永远指向首元节点），其他都完全一样。</p><h3 id="单向循环链表代码实现"><a href="#单向循环链表代码实现" class="headerlink" title="单向循环链表代码实现"></a>单向循环链表代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">circularLinkedListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//存放链表节点的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cLLNode</span>* <span class="title">next</span>;</span><span class="comment">//链表节点的指针域</span></span><br><span class="line">&#125;cLLNode;</span><br><span class="line"><span class="function">cLLNode* <span class="title">initCircularLinkedList</span><span class="params">()</span></span>;<span class="comment">//对单向循环链表进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">circularLinkedListIsEmpty</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//判断单向循环链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedList</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向单向循环链表尾部插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListHead</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向单向链表头部插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">firstCircularLinkedListEleadd</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//单向循环链表第一次插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outCircularLinkedList</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCircularLinkedList</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//将单向循环链表的所有的节点全部清空，只保留头指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCircularLinkedListLength</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//获取单向循环链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在第index个元素前插入一个元素，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListHead</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//删除单向循环链表的首元节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListTail</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//删除单向循环链表的尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index删除单向循环链表的节点，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index获取元素的值，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">cLLNode* head = initCircularLinkedList();</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">119</span>);</span><br><span class="line">addEleInCircularLinkedList(head, <span class="number">12</span>);</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">13</span>);</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">14</span>);</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">15</span>);</span><br><span class="line">addEleInCircularLinkedListByIndex(head, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">addEleInCircularLinkedListByIndex(head, <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">addEleInCircularLinkedListByIndex(head, <span class="number">7</span>, <span class="number">10000</span>);</span><br><span class="line">outCircularLinkedList(head);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表为的长度是%d\n&quot;</span>, getCircularLinkedListLength(head));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表的第8个元素是%d&quot;</span>,getEleCircularLinkedListByIndex(head,<span class="number">8</span>));</span><br><span class="line">clearCircularLinkedList(head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cLLNode* <span class="title">initCircularLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造单向循环链表的头节点</span></span><br><span class="line">cLLNode* head = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表创建失败==================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">circularLinkedListIsEmpty</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断单向循环链表是否为空失败======================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedList</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表尾插入元素失败===============&gt;参数错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;<span class="comment">//说明是第一次添加元素</span></span><br><span class="line">firstCircularLinkedListEleadd(head, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cLLNode* temp = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素失败=========&gt;空间不足&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != head-&gt;next) &#123;<span class="comment">//找到单向循环链表的最后一个节点</span></span><br><span class="line"></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">temp-&gt;next = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListHead</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表头插入元素失败===============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">firstCircularLinkedListEleadd(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line">cLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != head-&gt;next) &#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line">temp-&gt;next = p;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头插入元素失败===========&gt;空间不足\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">firstCircularLinkedListEleadd</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第一次插入失败========&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* temp = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素失败=========&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outCircularLinkedList</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历链表失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next != head-&gt;next) &#123;<span class="comment">//单向循环链表达到表尾的条件是最后一个指针域指向首元节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表中的第%d个元素是%d\n&quot;</span>, i, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表中的第%d个元素是%d\n&quot;</span>, i, p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCircularLinkedList</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空单链表失败=====================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line">cLLNode* temp;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">temp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCircularLinkedListLength</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;循环单链表插入元素失败===================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//判断是不是头插入</span></span><br><span class="line">addEleInCircularLinkedListHead(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i!= index) &#123;<span class="comment">//说明没有找到这个节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index插入元素失败=============&gt;没有这个元素\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || (p-&gt;next == head-&gt;next &amp;&amp; i + <span class="number">1</span> != index)) &#123;<span class="comment">//判断是否找到当前元素的前一个元素，!p成立的的话说明当前单向循环链表是空的，如果后面 (p-&gt;next == head-&gt;next &amp;&amp; i + 1 != index)同时成立的话说明就是没有找到节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素错误=======================&gt;index对应的节点不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里说明已经找到当前的节点的前一个节点</span></span><br><span class="line">cLLNode* temp = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素失败==========================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;data);</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListHead</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除单向循环链表的首元节点失败===================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == p) &#123;<span class="comment">//说明只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* temp = p-&gt;next;<span class="comment">//单向循环链表的第二个节点</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != head-&gt;next)<span class="comment">//查找最后一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* node = p-&gt;next;<span class="comment">//需要删除的首元节点</span></span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line"><span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListTail</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表尾删除失败================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line">cLLNode* temp = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == p) &#123;<span class="comment">//说明只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != head-&gt;next)<span class="comment">//找到需要删除的节点的的前一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">temp = p-&gt;next;<span class="comment">//因为不允许使用p-&gt;next-&gt;next，所以多增加一个temp变量，效果和p-&gt;next-&gt;next一样，方便找到最后一个节点的前一个节点，这个temp变量就是最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span> || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除节点失败==========================&gt;参数错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//说明是头删除</span></span><br><span class="line">deleteCircularLinkedListHead(head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == p) &#123;<span class="comment">//只有一个节点的情况</span></span><br><span class="line">deleteCircularLinkedListHead(head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i!= index) &#123;<span class="comment">//说明没有找到这个节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除元素失败=============&gt;没有这个元素\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* temp = p-&gt;next;<span class="comment">//temp表示的就是需要删除的节点</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> == index &amp;&amp; head-&gt;next == temp-&gt;next) &#123;<span class="comment">//说明是尾删除</span></span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取元素失败===========&gt;参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= index &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != index+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构中的单向循环链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="链表" scheme="https://i-fire.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>今日份开心</title>
    <link href="https://i-fire.top/post/todayHappiness.html"/>
    <id>https://i-fire.top/post/todayHappiness.html</id>
    <published>2021-02-21T11:39:53.000Z</published>
    <updated>2021-02-21T11:46:11.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天的快乐"><a href="#今天的快乐" class="headerlink" title="今天的快乐"></a>今天的快乐</h1><p>今天小学生开学了，我去了以前上小学的地方，门口的小店竟然有冷饮卖！开森！！</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210221193807.jpg"></p>]]></content>
    
    
    <summary type="html">开森</summary>
    
    
    
    <category term="心情随笔" scheme="https://i-fire.top/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="生活" scheme="https://i-fire.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>静态链表</title>
    <link href="https://i-fire.top/post/staticLinkedList.html"/>
    <id>https://i-fire.top/post/staticLinkedList.html</id>
    <published>2021-02-21T11:26:43.000Z</published>
    <updated>2021-02-21T11:28:54.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><h4 id="顺序表和链表的优缺点"><a href="#顺序表和链表的优缺点" class="headerlink" title="顺序表和链表的优缺点"></a>顺序表和链表的优缺点</h4><p>从之前写的动态数组（线性表的顺序存储方式）和单链表（线性表的链式存储方式）代码来说，二者都有一些优缺点，对于动态数组，<br>查询和写入（非存储）数据很快，但是当存储数据时，需要不停地移动元素，如果碰上动态数组满了的情况，那么还需要对动态数组进行扩容，对于存储来说，效率很低。对于链表来说，每次查询或者写入一个元素的时候，需要从头遍历整个链表来找到需要写入数据的节点，效率也不是很高，对于插入数据来说，只要找到当前节点的前驱，然后修改前驱节点的指针的指向即可，相比动态数组插入元素而言效率要高。有没有一种数据结构可以克服这些缺点同时继承他们的优点？？那就是<strong>静态链表</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>静态链表，也是线性存储结构的一种，它兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。<br>使用静态链表存储数据，数据全部在数组中（类似动态数组），但是存储的位置是随机的，数据之间的链式关系（一个接一个）通过一个整型变量（称之为<strong>游标，类似单链表中每个节点的指针</strong>）</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用静态链表存储数组{1,2,3}<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220092258.png"></p><p>接着，在将数据存放到数组中时，给各个数据元素配备一个整形变量，此变量用于指明各个元素的直接后继元素所在数组中的位置下标，如图 2 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220092407.png"></p><p>通常，静态链表会将第一个数据元素放到数组下标为 1 的位置（a[1]）中。<br>图 2 中，从 a[1] 存储的数据元素 1 开始，通过存储的游标变量 3，就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样，通过元素 a[3] 存储的游标变量 5，可以在 a[5] 中找到元素 2 的直接后继元素 3，这样的循环过程直到某元素的游标变量为 0 截止（因为 a[0] 默认不存储数据元素）。<br>类似图 2 这样，通过 “数组+游标” 的方式存储具有线性关系数据的存储结构就是静态链表。</p><h3 id="静态链表中的节点"><a href="#静态链表中的节点" class="headerlink" title="静态链表中的节点"></a>静态链表中的节点</h3><p>静态链表中的节点也包含两个部分，但是和单链表不同的就是单链表节点中的指针域变成了静态链表中的<strong>游标</strong>，游标不是一个指针，它记录的是当前节点的下一个节点在数组中的位置（也就是数组元素的下标）</p><ul><li>数据域：存储数据元素</li><li>游标：其实就是数组下标，表示直接后继元素所在数组中的位置；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tydef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> cursor;<span class="comment">//游标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备用链表"><a href="#备用链表" class="headerlink" title="备用链表"></a>备用链表</h3><p>可以看到，图2中的数组不是很完整：数据中有6个位置，但是实际上值存储了3个元素，空出来了3个位置，这三个位置我们也是可以利用的。在静态链表中，除了数据本身通过游标组成的链表外，还需要有一条连接各个空闲位置的链表，称之为备用链表。<br>备用链表的作用是回收数组中未使用或者之前使用但是目前没有使用的存储空间，以待后期使用，也就是说，静态链表使用数组申请的物理空间，存在两个链表，一个连接着数据，另外一条连接着数组中还未使用过的空间</p><blockquote><p>通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。</p></blockquote><p>在静态链表中使用备用链表的好处就是可以清楚地知道数组中是否有空闲位置，一遍数据链表添加数据的时候使用。如果静态链表中数组下标为0的位置上存有数据，则证明数组满了<br>例如，使用静态链表存储 <code>&#123;1,2,3&#125;</code>，假设使用长度为 6 的数组 a，则存储状态可能如图 3 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220093947.png"></p><h3 id="静态链表的实现"><a href="#静态链表的实现" class="headerlink" title="静态链表的实现"></a>静态链表的实现</h3><p>假设静态链表（长度为6）存储{1,2,3}，需要经过如下几个阶段<br>当链表没有进行初始化的时候，数组中的所有的位置都处于空闲转态，因此都应该被连接都备用链表上<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220100716.png"></p><blockquote><p>备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表</p></blockquote><p>因此，在图 4 的基础上，向静态链表中添加元素 1 的过程如图 5 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220100919.png"></p><p>在图 5 的基础上，添加元素 2 的过程如图 6 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220101301.png"></p><p>在图 6 的基础上，继续添加元素 3 ，过程如图 7 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220101448.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> typename int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  next;</span><br><span class="line">    <span class="keyword">typename</span> context;</span><br><span class="line">&#125;Node,List[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStatic</span><span class="params">(Node *l)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_Length</span><span class="params">(Node *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(Node *l,<span class="keyword">int</span> i,<span class="keyword">typename</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Node *l,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List <span class="built_in">list</span>;</span><br><span class="line">    InitStatic(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">int</span> h,i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h);</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>].next = h;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> f;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f);</span><br><span class="line">        <span class="built_in">list</span>[i].context = f;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>[h<span class="number">-1</span>].next = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>[MAX - <span class="number">1</span>].next = <span class="number">1</span>;<span class="comment">//为已用链表的头结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;长度为：%d\n&quot;</span>,get_Length(<span class="built_in">list</span>));</span><br><span class="line">    print(<span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;长度为：%d\n&quot;</span>,get_Length(<span class="built_in">list</span>));</span><br><span class="line">    <span class="comment">/*Insert(list,1,5);</span></span><br><span class="line"><span class="comment">    printf(&quot;长度为：%d\n&quot;,get_Length(list));*/</span></span><br><span class="line">    print(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStatic</span><span class="params">(Node *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        l[i].context = <span class="number">0</span>;</span><br><span class="line">        l[i].next = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l[MAX - <span class="number">1</span>].next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLode</span><span class="params">(Node *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">list</span>[<span class="number">0</span>].next;</span><br><span class="line">    <span class="keyword">if</span>(m) &#123;</span><br><span class="line">        <span class="built_in">list</span>[<span class="number">0</span>].next = <span class="built_in">list</span>[m].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得有效长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_Length</span><span class="params">(Node *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>,i = <span class="built_in">list</span>[MAX - <span class="number">1</span>].next;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">        i = <span class="built_in">list</span>[i].next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(Node *l,<span class="keyword">int</span> i,<span class="keyword">typename</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = getLode(l),j = <span class="number">1</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; get_Length(l) + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入错误！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        l[MAX - <span class="number">1</span>].next = m;</span><br><span class="line">        l[m].next = <span class="number">1</span>;</span><br><span class="line">        l[m].context = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;j &lt; i - <span class="number">1</span>;j++)  k = l[k].next;</span><br><span class="line">        l[m].context = x;</span><br><span class="line">        l[m].next = l[k].next;</span><br><span class="line">        l[k].next = m;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Node *l,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>,m = <span class="number">1</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">        f = l[MAX - <span class="number">1</span>].next;</span><br><span class="line">        l[MAX - <span class="number">1</span>].next = l[f].next;</span><br><span class="line">        l[f].next = l[<span class="number">0</span>].next;</span><br><span class="line">        l[<span class="number">0</span>].next = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;j &lt; k - <span class="number">1</span>;j++) m = l[m].next;</span><br><span class="line">    k = l[m].next;</span><br><span class="line">    l[m].next = l[k].next;</span><br><span class="line">    l[k].next = l[<span class="number">0</span>].next;</span><br><span class="line">    l[<span class="number">0</span>].next = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据的展示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">list</span>[MAX - <span class="number">1</span>].next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>[i].next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据为：%d\n&quot;</span>,<span class="built_in">list</span>[i].context);</span><br><span class="line">        i = <span class="built_in">list</span>[i].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据为：%d\n&quot;</span>,<span class="built_in">list</span>[i].context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，静态链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="静态链表" scheme="https://i-fire.top/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>线性结构（）二</title>
    <link href="https://i-fire.top/post/linearStructureTwo.html"/>
    <id>https://i-fire.top/post/linearStructureTwo.html</id>
    <published>2021-02-19T09:28:03.000Z</published>
    <updated>2021-02-19T09:29:06.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>链式存储结构，由于它不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的缺点<br>借助指针等手段来表示数据元素 a<sub>i</sub> 和直接后继元素 a<sub>i+1</sub> 之间的关系，a<sub>i</sub> 不仅存储本身的信息，还存储指向后继的指针。<br>数据元素（数据域）和指向后继的指针（指针域）合起来称为一个结点，n 个结点链接成一个链表即为线性表的链式存储结构。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ul><li>数据域：存储真实的数据元素</li><li>指针域：下一个节点的地址（指针）</li></ul><pre class="mermaid">graph TDA[节点] --> B[数据域]A[节点] --> C[指针域]</pre><h3 id="首元节点"><a href="#首元节点" class="headerlink" title="首元节点"></a>首元节点</h3><p>链表中第一个存放数据的元素所在的结点，它是头结点后边的第一个结点。</p><h3 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a>头指针</h3><p>一般把<strong>链表</strong>中的<strong>第一个结</strong>点称为 <strong>头指针</strong>，其<strong>存储</strong>链表的<strong>第一个数据元素</strong>，在有头节点的情况下头指针指向的应该是指向的是头节点，无头节点的情况下头指针指向的是首元节点</p><h3 id="头节点"><a href="#头节点" class="headerlink" title="头节点"></a>头节点</h3><p>为了能更加方便地对链表进行操作，会在<strong>单链表的第一个结点（即头指针）前</strong>附<strong>设一个结点</strong>，称为 <strong>头结点</strong>，头节点中可以存储一些附加数据，例如：当前线性表的长度等等,在处理某些问题时，给链表添加头结点会使问题变得简单。</p><pre class="mermaid">graph LRO[头指针]-->A[头节点]A[头节点]-->B[线性表的首元节点]A[头节点]-->C[线性表的长度]A[头节点]-->D[线性表的尾指针]A[头节点]-->M[还可以再加....]B[线性表的首元节点]-->E[数据域]B[线性表的首元节点]-->F[指针域]F[指针域]-->G[线性表节点]G[线性表节点]-->H[数据域]G[线性表节点]-->I[指针域]I[指针域]-->J[线性表节点]J[线性表节点]-->K[数据域]J[线性表节点]-->L[指针域]</pre><pre class="mermaid">graph LRO[头指针]-->B[线性表的首元节点]B[线性表的首元节点]-->E[数据域]B[线性表的首元节点]-->F[指针域]F[指针域]-->G[线性表节点]G[线性表节点]-->H[数据域]G[线性表节点]-->I[指针域]I[指针域]-->J[线性表节点]J[线性表节点]-->K[数据域]J[线性表节点]-->L[指针域]</pre><p><strong>头结点和头指针的区别</strong>：头指针是一个指针，头指针指向链表的头结点或者首元结点；头结点是一个实际存在的结点，它包含有数据域和指针域。两者在程序中的直接体现就是：头指针只声明而没有分配存储空间，头结点进行了声明并分配了一个结点的实际物理内存。单链表中可以没有头结点，但是不能没有头指针！</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>在单链表中，对于每个结点来说，除了存储本身的信息外，还需要存放一个指向其后继的指针。逻辑位置相<br>邻但物理位置不相邻的数据元素用单链表链接<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210219085612.png"></p><ul><li>对于存取操作：而对于单链表结构，假设需要获取第 i 个元素，则必须从第一个结点开始依次进行遍历，直到达到第 i 个结点。因此，对于单链表结构而言，其数据元素读取的<strong>时间复杂度</strong>为<strong>O<sub>(n)</sub></strong></li><li>对于<strong>插入和删除</strong>操作：而对单链表结构来说，对其任意一个位置进行增删操作，其<strong>时间复杂度</strong>为 O<sub>(n)</sub>，<strong>因为</strong>需要先进行<strong>遍历找到目标元素</strong>，对头指针的增删操作其<strong>时间复杂度</strong>为O<sub>(1)</sub></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义单链表节点的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">singleLinkedListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//节点中的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singleLinkedListNode</span>* <span class="title">next</span>;</span><span class="comment">//节点中的指针域</span></span><br><span class="line">&#125; sLLNode;</span><br><span class="line"><span class="function">sLLNode* <span class="title">initSingleLinkedList</span><span class="params">()</span></span>;<span class="comment">//初始化单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListHead</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//单链表头插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outSingleLinkedList</span><span class="params">(sLLNode* head)</span></span>;<span class="comment">//遍历输出单链表中所有的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySingleLinkedList</span><span class="params">(sLLNode** head)</span></span>;<span class="comment">//销毁单链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListLength</span><span class="params">(sLLNode* head)</span></span>;<span class="comment">//获取单链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInSingleLinkedList</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在单链表的尾部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//获取单链表中第index个元素，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在第index个位置前添加一个元素，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteSingleLinkedListByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//删除第index位置上的元素，同时将它返回出去，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//根据数据查找对应的index，没有就返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">sLLNode* singleLinkedList = initSingleLinkedList();</span><br><span class="line">addSingleLinkedListHead(singleLinkedList, <span class="number">1</span>);</span><br><span class="line">addSingleLinkedListHead(singleLinkedList, <span class="number">11</span>);</span><br><span class="line">addEleInSingleLinkedList(singleLinkedList, <span class="number">100</span>);</span><br><span class="line">addSingleLinkedListHead(singleLinkedList, <span class="number">122</span>);</span><br><span class="line">addEleInSingleLinkedList(singleLinkedList, <span class="number">100</span>);</span><br><span class="line">addEleInSingleLinkedList(singleLinkedList, <span class="number">100</span>);</span><br><span class="line">addSingleLinkedListEleByIndex(singleLinkedList, <span class="number">1</span>, <span class="number">90</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表中第%d个元素是%d\n&quot;</span>, <span class="number">1</span>, getSingleLinkedListEleByIndex(singleLinkedList, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表中第%d个元素是%d\n&quot;</span>, <span class="number">2</span>, getSingleLinkedListEleByIndex(singleLinkedList, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addSingleLinkedListEleByIndex(singleLinkedList, <span class="number">20</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1000所在的第一个节点的index是%d\n&quot;</span>,findEleByIndex(singleLinkedList,<span class="number">1000</span>));</span><br><span class="line">deleteSingleLinkedListByIndex(singleLinkedList, <span class="number">2</span>);</span><br><span class="line">outSingleLinkedList(singleLinkedList);</span><br><span class="line">destorySingleLinkedList(&amp;singleLinkedList);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表的长度是%d&quot;</span>, getSingleLinkedListLength(singleLinkedList));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sLLNode* <span class="title">initSingleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造出头指针</span></span><br><span class="line">sLLNode* head = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化单链表失败，失败原因===================&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListHead</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表头插入失败，失败原因=======================&gt;参数不合法\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* p = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表的头插入失败，失败原因==================&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="comment">//用临时变量保存原来的头节点后面一个节点的地址</span></span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outSingleLinkedList</span><span class="params">(sLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历单链表失败，失败原因=======================&gt;参数不合法\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表中第%d个元素是====================&gt;%d\n&quot;</span>, i, temp-&gt;data);</span><br><span class="line">i++;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySingleLinkedList</span><span class="params">(sLLNode** head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || !(*head)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁单链表失败======================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* p = *head;</span><br><span class="line">sLLNode* temp;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">temp = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = temp;</span><br><span class="line">&#125;</span><br><span class="line">*head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListLength</span><span class="params">(sLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取单链表长度失败====================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (temp)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInSingleLinkedList</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在单链表尾部插入元素失败============================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* temp = head;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next) &#123;<span class="comment">//当当前节点的下一个节点为空时，说明已经抵达单链表的最后一个节点！</span></span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* node = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (!node) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在单链表尾部插入元素失败===================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;<span class="comment">//一定一定要将最后一个节点的next指针置为NULL！！！</span></span><br><span class="line">temp-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取单链表中数组失败===========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; temp)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line"><span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在单链表指定位置添加元素失败===========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//判断是不是头添加,需要将指针p指向头指针并非是头节点，这样才能找到头添加时需要的前驱</span></span><br><span class="line">p = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index - <span class="number">1</span> &amp;&amp; p) &#123;<span class="comment">//需要找到index位置的节点的前驱所以是p-&gt;next</span></span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">sLLNode* temp = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">sLLNode* currentNode = p-&gt;next;<span class="comment">//currentNode中保存的才是对应单链表中第index个节点</span></span><br><span class="line">temp-&gt;next = currentNode;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表指定位置添加元素失败！==========================&gt;空间不足！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表指定位置添加元素失败！==========================&gt;index位置的节点不存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteSingleLinkedListByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除单链表元素失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span> &amp;&amp; head-&gt;next) &#123;<span class="comment">//判断是不是头删除</span></span><br><span class="line">temp = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index - <span class="number">1</span> &amp;&amp; temp) &#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line">sLLNode* currentNode = temp-&gt;next;</span><br><span class="line">temp-&gt;next = currentNode-&gt;next;</span><br><span class="line">data = currentNode-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(currentNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除元素失败========================&gt;index对应的元素不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据值查找index失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;data == e) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，单链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线性结构" scheme="https://i-fire.top/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性结构（一）</title>
    <link href="https://i-fire.top/post/linearStructureOne.html"/>
    <id>https://i-fire.top/post/linearStructureOne.html</id>
    <published>2021-02-19T09:23:57.000Z</published>
    <updated>2021-02-19T09:27:00.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性结构（一）"><a href="#线性结构（一）" class="headerlink" title="线性结构（一）"></a>线性结构（一）</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>含有n个相同元素的数据元素的有限序列称为线性表<br>一般可以表示为：L(a<sub>1</sub>,a<sub>2</sub>,…….,a<sub>n-1</sub>,a<sub>n</sub>)<strong>注意：</strong>a<sub>i-1</sub> 是 a<sub>i</sub> 的直接前驱元素，a<sub>i+1</sub> 是 a<sub>n</sub> 的直接后继元素。线性表中数据元素的个数 n（n＞0）为线性表的长度。当 n＝0 时称线性表为空表。</p><h3 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h3><pre class="mermaid">graph TDA[线性表] --> B[顺序存储结构]A[线性表] --> C[链式存储结构]B[顺序存储结构] --> D[动态数组]C[链式存储结构] --> E[单链表]C[链式存储结构] --> F[静态链表]C[链式存储结构] --> H[循环链表]C[链式存储结构] --> I[双向链表]</pre><h3 id="顺序存储结构-动态数组"><a href="#顺序存储结构-动态数组" class="headerlink" title="顺序存储结构(动态数组)"></a>顺序存储结构(动态数组)</h3><p>（又称顺序表）是一种随机存取的结构，逻辑关系上相邻的元素物理位置上也相邻。数组是表<br>示顺序存储结构最简单的一个方式。如图 2-1 所示，只要确定了存储线性表的起始位置，线性表中任一数据元素<br>都可随机存取。<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210219082748.png"></p><p><strong>顺序存储结构的特点</strong></p><p>优点：</p><p>①它是一个记录型的结构。数据元素的存储位置可用数组的下标值（即相对于线性表的起始位置的值）来表</p><p>示；</p><p>②在顺序存储结构中，线性表的某些操作容易实现，如求表长的操作；</p><p>缺点：</p><p>①在做插入或删除操作时，需移动大量元素；</p><p>②在给长度变化较大的线性表预先分配空间时，必须按最大空间分配，易造成了空间的浪费；</p><p>③表的容量难以扩充</p>]]></content>
    
    
    <summary type="html">数据结构</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线性结构" scheme="https://i-fire.top/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>谷歌浏览器时区问题</title>
    <link href="https://i-fire.top/post/chrom.html"/>
    <id>https://i-fire.top/post/chrom.html</id>
    <published>2021-02-01T01:47:17.000Z</published>
    <updated>2021-02-01T01:56:05.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决谷歌浏览器时间不同步问题"><a href="#解决谷歌浏览器时间不同步问题" class="headerlink" title="解决谷歌浏览器时间不同步问题"></a>解决谷歌浏览器时间不同步问题</h1><p>昨天站长在谷歌浏览器测试项目的时候奇怪的发现，前端js同一个时间戳解析出来的时间与我的本地时区相差16个小时（之前在项目中就有疑惑，后台发现用户总是喜欢在凌晨注册，没有引起好奇），我是在东八区（<a href="https://baike.baidu.com/item/UTC">UTC</a>/<a href="https://baike.baidu.com/item/GMT/6026868">GMT</a>+08:00），但是时间戳格式化出来的却是西八区（<a href="https://baike.baidu.com/item/UTC">UTC</a>/<a href="https://baike.baidu.com/item/GMT/6026868">GMT</a>-08:00），我一直以为是js没有设置时区问题（一般来说都会按照本地时区对时间戳进行格式化，基本不会让开发者自己设置），于是我各种百度，找到的解决办法也是五花八门（到此为止我还没有意识到是谷歌浏览器自己出问题，并非是我的电脑问题），然后我才想起来同一个时间戳放到不同的浏览器上去解析一下，验证是不是我的时区问题。嘿！edge，火狐都没有问题，就是谷歌出问题，最后在一个贴吧老哥那里找到的解决办法——-》修改电脑时区</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul><li><p>先将自己的时区随便设置一个，这里要先关掉自动设置时区，然后才能自己设置时区</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210201094157.png"></p></li><li><p>接着再将本地的时区改回来，我这里是东八区，于是我在改回东八区，至此问题解决</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210201094338.png"></p></li></ul>]]></content>
    
    
    <summary type="html">谷歌浏览器格式化时间与本地时区相差16小时</summary>
    
    
    
    <category term="小技巧" scheme="https://i-fire.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="chrome" scheme="https://i-fire.top/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>我爱签到网使用教程</title>
    <link href="https://i-fire.top/post/52sign.html"/>
    <id>https://i-fire.top/post/52sign.html</id>
    <published>2021-01-17T02:43:30.000Z</published>
    <updated>2021-01-17T03:16:11.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我爱签到网使用教程"><a href="#我爱签到网使用教程" class="headerlink" title="我爱签到网使用教程"></a>我爱签到网使用教程</h1><h3 id="平台介绍"><a href="#平台介绍" class="headerlink" title="平台介绍"></a>平台介绍</h3><p>一个集成了各大平台打卡签到功能的系统，基于springboot和layui开发，大部分功能完全免费</p><h3 id="目前已经有的功能"><a href="#目前已经有的功能" class="headerlink" title="目前已经有的功能"></a>目前已经有的功能</h3><ul><li>学习通签到<ul><li>普通签到</li><li>位置签到</li><li>手势签到</li></ul></li><li>网易云打卡<ul><li>云贝打卡</li><li>每日听歌300首</li></ul></li></ul><p><strong>PS：只要保持各大平台的密码正确，完全可以实现自动化签到，彻底解放双手</strong></p><p><strong>PS：后续会添加更多自动化功能</strong></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li><p>打卡我爱签到网网址：<a href="https://52sign.top/">https://52sign.top/</a></p></li><li><p>点击注册用户，点击这两处都行</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117100006.png"></p></li><li><p>按照要求输入相应的信息即可，然后点击注册</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117100213.png"></p></li><li><p>注册成功后会收到一封激活邮箱的邮件，只有先激活邮箱，才能登陆网站</p></li><li><p>然后登陆到网站里面，看到当前页面说明注册成功</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117102141.png"></p></li><li><p>登陆成功后即可开始使用（以学习通签到为例）</p><ul><li><p>首先需要添加一个学习通账号</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117102605.png"></p></li></ul></li><li><p>添加完毕后获取学习通账户的所有课程</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117102839.png"></p><p>选择刚才添加的学习通账号，然后获取到账号中的所有的课程后</p><ul><li><p>为课程添加签到任务</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117103156.png"></p></li><li><p>查看签到所有的签到任务</p><p><img src="C:\Users\15061\AppData\Roaming\Typora\typora-user-images\image-20210117103344648.png"></p></li><li><p>查看学习通签到日志</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117103415.png"></p></li></ul><p><strong>注意：数据库中的数据没10分钟才会同步一次，有时候日志里面没有数据不代表没签上，具体以学习通是否签到为准</strong></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>至此演示了学习通签到任务的添加流程，网易云也是大同小异，请自己研究一下！！</p>]]></content>
    
    
    <summary type="html">全自动打卡，彻底解放你的双手，让您专注于手头的任务上</summary>
    
    
    
    <category term="项目" scheme="https://i-fire.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://i-fire.top/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="我爱签到网" scheme="https://i-fire.top/tags/%E6%88%91%E7%88%B1%E7%AD%BE%E5%88%B0%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>警醒</title>
    <link href="https://i-fire.top/post/warn.html"/>
    <id>https://i-fire.top/post/warn.html</id>
    <published>2021-01-15T00:47:12.000Z</published>
    <updated>2021-01-15T00:55:18.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="警戒"><a href="#警戒" class="headerlink" title="警戒"></a>警戒</h1><p>今天是2021年1月15号，谨以此文章记录一年前的今天我在某重大战役中的胜利</p><p><strong>凡事必须三思而后行</strong></p>]]></content>
    
    
    <summary type="html">警戒</summary>
    
    
    
    <category term="大事记" scheme="https://i-fire.top/categories/%E5%A4%A7%E4%BA%8B%E8%AE%B0/"/>
    
    
    <category term="生活" scheme="https://i-fire.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>选择排序 SelectSort</title>
    <link href="https://i-fire.top/post/xuanze.html"/>
    <id>https://i-fire.top/post/xuanze.html</id>
    <published>2020-12-26T10:46:22.000Z</published>
    <updated>2020-12-26T10:51:22.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>从头到尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下来的元素中继续这种选择和交换方式，最终得到一个有序序列</p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20201226182244.gif" alt="选择排序动画演示"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="keyword">int</span> *arr)</span></span>;<span class="comment">//嵌套for循环进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="keyword">int</span> *arr)</span></span>;<span class="comment">//一个递归加上一个for循环进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">15</span>]= &#123;<span class="number">12</span>,<span class="number">3123</span>,<span class="number">434</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">65</span>,<span class="number">12</span>,<span class="number">78</span>,<span class="number">87</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6799</span>,<span class="number">89</span>,<span class="number">20</span>,<span class="number">12</span>&#125;; <span class="comment">//定义需要排序的数组</span></span><br><span class="line">sortTwo(<span class="number">15</span>,&amp;arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="keyword">int</span> *arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//数组长度小于2，不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> iminpos=<span class="number">0</span>;<span class="comment">//记录每趟循环中最小值的下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">iminpos = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> jj = i+<span class="number">1</span>; jj&lt;length; jj++) &#123;<span class="comment">//下标从jj开始的元素中的最小值，将最小值的下标赋值给 iminpos</span></span><br><span class="line"><span class="keyword">if</span>(arr[jj]&lt;arr[iminpos]) &#123;</span><br><span class="line">iminpos=jj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(iminpos!=i) &#123;<span class="comment">//对找出来的最小值  arr[iminpos]和 arr[i]交换顺序 </span></span><br><span class="line"><span class="keyword">int</span> temp = arr[iminpos];</span><br><span class="line">arr[iminpos] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="keyword">int</span> *arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//数组长度小于2，不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> iminpos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> jj =<span class="number">1</span>; jj&lt;length; jj++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[jj]&lt;arr[iminpos]) &#123;<span class="comment">//下标从jj开始的元素中的最小值，将最小值的下标赋值给 iminpos</span></span><br><span class="line">iminpos=jj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(iminpos!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[iminpos];<span class="comment">//将找到的最小值放入传入的数组的第一个位置，由于每一次的递归都会将数组的指针向后移动一个，所以arr[0]的位置是在不停的不变化 </span></span><br><span class="line">arr[iminpos]=temp;</span><br><span class="line">&#125;</span><br><span class="line">sortTwo(--length,arr+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">选择排序，算法</summary>
    
    
    
    <category term="算法" scheme="https://i-fire.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://i-fire.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="选择排序" scheme="https://i-fire.top/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序 BubbleSort</title>
    <link href="https://i-fire.top/post/maopao.html"/>
    <id>https://i-fire.top/post/maopao.html</id>
    <published>2020-11-20T08:28:37.000Z</published>
    <updated>2020-11-20T08:32:42.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在排序的的过程中，会依次的对相邻的两个元素进行比较，如果左边的元素大于右边的元素，那么就会将这两个元素进行交换，类似气泡一样左右浮动</p><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20201120153054.gif" alt="冒泡排序图示"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>通过上面的图示，我们可以看到每次移动元素都是从左边第一个依次的向后进行比较，这样我们就以通过一个for循环实现，此外，每次走遍一整个的比较循环，会将当前需要排序的数组中的最大值排在按序排在数组的尾部，所以我们还需要一个for循环来控制有多少个找出数组剩余元素最大值的循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;<span class="comment">//使用两个for循环实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">15</span>]= &#123;<span class="number">12</span>,<span class="number">3123</span>,<span class="number">434</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">65</span>,<span class="number">12</span>,<span class="number">78</span>,<span class="number">87</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6799</span>,<span class="number">89</span>,<span class="number">20</span>,<span class="number">12</span>&#125;; <span class="comment">//定义需要排序的数组</span></span><br><span class="line">sortOne(&amp;arr[<span class="number">0</span>],<span class="number">15</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;<span class="comment">//对排序后的数组进行输出，看看是否真的排序成功</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的第%d个元素是%d\n&quot;</span>,(i+<span class="number">1</span>),arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//元素小于两个的数组不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=count<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;<span class="comment">//控制内层找出数组剩余元素最大值的循环的次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;<span class="comment">//每次都会将数组的长度减一，因为一个找出数组剩余元素最大值的循环就会找出当前数组中的最大值，并按序放置在数组的尾部，每次需要比较的都是剩下来的没有比较的数组</span></span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123; <span class="comment">//如果后一个的值小于前一个值，那么就交换顺序</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个for循环的方法，还可以衍生出一个for循环+一个递归实现冒泡排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;<span class="comment">//使用一个for循环和一个递归实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">15</span>]= &#123;<span class="number">12</span>,<span class="number">3123</span>,<span class="number">434</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">65</span>,<span class="number">12</span>,<span class="number">78</span>,<span class="number">87</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6799</span>,<span class="number">89</span>,<span class="number">20</span>,<span class="number">12</span>&#125;; <span class="comment">//定义需要排序的数组</span></span><br><span class="line">sortTwo(&amp;arr[<span class="number">0</span>],<span class="number">15</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;<span class="comment">//对排序后的数组进行输出，看看是否真的排序成功</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的第%d个元素是%d\n&quot;</span>,(i+<span class="number">1</span>),arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//元素小于两个的数组不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123;<span class="comment">//如果后一个的值小于前一个值，那么就交换顺序</span></span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line">arr[i]=arr[i+<span class="number">1</span>];</span><br><span class="line">arr[i+<span class="number">1</span>]=temp; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortTwo(arr,--count);<span class="comment">//将原来控制找出数组剩余元素最大值的循环次数的外层for循环替换成了递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>上述的两种实现方式都存在一个问题，就是在排序的过程中需要排序的数组就已经因为原数组元素的顺序问题已经达到从小到大的排序的目的，但是循环还没有停止，这样就会造成不必要的内存开销，那么我们可以对上述的两种方式进行优化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;<span class="comment">//使用两个for循环实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count,<span class="keyword">int</span> n)</span></span>;<span class="comment">//使用一个for循环和一个递归实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">9</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">71</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; <span class="comment">//定义需要排序的数组</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;<span class="comment">//用来记录循环的次数</span></span><br><span class="line">sortOne(&amp;arr[<span class="number">0</span>],<span class="number">9</span>);</span><br><span class="line">sortTwo(&amp;arr[<span class="number">0</span>],<span class="number">9</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的第%d个元素是%d\n&quot;</span>,(i+<span class="number">1</span>),arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//元素小于两个的数组不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;<span class="comment">//用来记录循环的次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=count<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> isSwap=<span class="number">0</span>;<span class="comment">//用来记录内层循环是否发生了元素之间的交换，0：没有发生交换，1：发生了交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123; <span class="comment">//如果后一个的值小于前一个值，那么就交换顺序</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">isSwap=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isSwap==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;循环了%d次\n&quot;</span>,n);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//如果没有发生元素的交换，那么说明排序已经完成，那么接下来直接结束循环就可以了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;循环了%d次\n&quot;</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isSwap=<span class="number">0</span>;<span class="comment">//用来记录内层循环是否发生了元素之间的交换，0：没有发生交换，1：发生了交换</span></span><br><span class="line"><span class="keyword">if</span>(count&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//元素小于两个的数组不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count<span class="number">-1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line">arr[i]=arr[i+<span class="number">1</span>];</span><br><span class="line">arr[i+<span class="number">1</span>]=temp;</span><br><span class="line">isSwap=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isSwap==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;循环了%d次\n&quot;</span>,n);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//如果没有发生元素的交换，那么说明排序已经完成，那么接下来直接结束循环就可以了</span></span><br><span class="line">&#125;</span><br><span class="line">sortTwo(arr,--count,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用一个变量来记录在排序还没有停止，但是实际上已经将数组排序完毕的情况，这样可以大大的较少不必要的开销</p>]]></content>
    
    
    <summary type="html">冒泡排序，算法</summary>
    
    
    
    <category term="算法" scheme="https://i-fire.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://i-fire.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="冒泡排序" scheme="https://i-fire.top/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>DynamicArray 动态数组</title>
    <link href="https://i-fire.top/post/dynamicarray.html"/>
    <id>https://i-fire.top/post/dynamicarray.html</id>
    <published>2020-11-14T11:03:09.000Z</published>
    <updated>2021-02-19T09:27:13.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><p>在c语言中我们都听过数组，创建一个数组也很简单，例如我们创建一个简单的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//这样我们就创建好了一个数组，并且对其进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的数组创建好后，数组的大小就会被固定下来，当我们想要添加第三个元素的时候，那么就无法添加成功，怎么解决？？？</p><p>我们可以使用动态数组这样的线性结构来解决数组不能够增大容量的问题</p><h2 id="动态数组-1"><a href="#动态数组-1" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>动态数组，顾名思义就是能够动态的添加元素（从堆内存动态的分配存储空间），不会存在容量满了这一说法，只要我想添加元素，那么就可以添加元素</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>动态数组的实现我们可以依托c语言提供的普通数组实现，定义一个结构体变量，结构体变量中有三个元素</p><ul><li><p>int * P：用来保存一个数组，数组中存储的是用户自定义的数据</p></li><li><p>unsigned int Container：数组的容量</p></li><li><p>unsigned int I：数组已经存储元素的数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DynamicArray</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> * P;<span class="comment">//数组的头指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Container;<span class="comment">//数组的容量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> I;<span class="comment">//数组已经存储元素的数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="动态数组常用的方法"><a href="#动态数组常用的方法" class="headerlink" title="动态数组常用的方法"></a>动态数组常用的方法</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="comment">//定义结构体，用来保存动态数组的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> length;<span class="comment">//动态数组的总容量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> currentContainer;<span class="comment">//动态数组当前已经存放了多少个元素</span></span><br><span class="line"><span class="keyword">int</span>* p;<span class="comment">//保存静态数组的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态数组的常用操作方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">// 初始化动态数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向动态数组中插入一个元素（尾插入）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expandDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//动态数组进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDynamicArrayEle</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//获取动态数组中的一个元素，index从0开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//销毁动态数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//判断动态数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addEleByIndex</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向数组中的任意位置添加一个元素,index从0开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addInHead</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在动态数组头部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//清空动态数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//遍历输出数组所有的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEle</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//删除动态数组中的一个元素,下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个没有初始化的动态数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dynamicArray</span> <span class="title">array</span>;</span></span><br><span class="line"><span class="comment">//对动态数组进行初始化</span></span><br><span class="line">initDynamicArray(&amp;<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">1</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">3</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">4</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">5</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">32</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">33</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">31</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">3</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">23</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deleteEle(&amp;<span class="built_in">array</span>, <span class="number">1</span>);</span><br><span class="line">deleteEle(&amp;<span class="built_in">array</span>, <span class="number">1</span>);</span><br><span class="line">deleteEle(&amp;<span class="built_in">array</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addEleByIndex(&amp;<span class="built_in">array</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">addEleByIndex(&amp;<span class="built_in">array</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">addEleByIndex(&amp;<span class="built_in">array</span>,<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">out(&amp;<span class="built_in">array</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断传递的是否是null</span></span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化方法中传递的参数不合法\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dynamicArray-&gt;length = <span class="number">5</span>;<span class="comment">//初始化数据的容量</span></span><br><span class="line">dynamicArray-&gt;currentContainer = <span class="number">0</span>;<span class="comment">//初始化时没有任何的元素</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">5</span>);<span class="comment">//初始化时分配5个存储空间</span></span><br><span class="line"><span class="comment">//判断是否成功申请到空间</span></span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化失败,失败原因=============&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dynamicArray-&gt;p = p;<span class="comment">//将动态数组中的静态数组指针指向初始化的空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;向动态数组中添加元素错误，失败原因==================&gt;动态数组地址错误！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断动态数组中是否满了，如果满了就扩容</span></span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;length == dynamicArray-&gt;currentContainer &amp;&amp; FALSE == expandDynamicArray(dynamicArray)) &#123;</span><br><span class="line"><span class="comment">//扩容失败，直接返回</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;添加元素失败，失败原因====================&gt;空间不足，无法扩容\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">(dynamicArray-&gt;p)[dynamicArray-&gt;currentContainer] = e;</span><br><span class="line"><span class="comment">//这里的currentContainer有两个作用，第一个就是记录数组中已经存放了多少个元素，其次就是数组中已有元素中的最后一个元素的下一个元素的下标</span></span><br><span class="line">dynamicArray-&gt;currentContainer = dynamicArray-&gt;currentContainer + <span class="number">1</span>;<span class="comment">//当前数组的长度+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expandDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (dynamicArray-&gt;length + <span class="number">5</span>));<span class="comment">//扩容</span></span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;动态数组扩容失败！原因=======================&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">dynamicArray-&gt;length = dynamicArray-&gt;length + <span class="number">5</span>;<span class="comment">//动态数组的长度+5</span></span><br><span class="line"><span class="comment">//将原来的动态数组中的数据拷贝到新的数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dynamicArray-&gt;currentContainer; i++) &#123;</span><br><span class="line">p[i] = (dynamicArray-&gt;p)[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(dynamicArray-&gt;p);<span class="comment">//释放原来的空间</span></span><br><span class="line">dynamicArray-&gt;p = p;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDynamicArrayEle</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span> || index &gt;= dynamicArray-&gt;currentContainer) &#123;<span class="comment">//传递的index越界也是不行的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取元素失败，原因================&gt;传递参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (dynamicArray-&gt;p)[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁动态数组失败，原因================&gt;传递参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放数组空间</span></span><br><span class="line"><span class="built_in">free</span>(dynamicArray-&gt;p);</span><br><span class="line"><span class="comment">//数组的总长度和已经存放的元素的长度全部置为0</span></span><br><span class="line">dynamicArray-&gt;currentContainer = <span class="number">0</span>;</span><br><span class="line">dynamicArray-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断数组是否为空失败，原因================&gt;传递参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;currentContainer &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addEleByIndex</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span> || index&lt;<span class="number">0</span> || index&gt;dynamicArray-&gt;length) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据下标添加元素失败，失败原因===============&gt;参数不合法&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;currentContainer == dynamicArray-&gt;length &amp;&amp; FALSE == expandDynamicArray(dynamicArray)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据下标添加元素失败，失败原因===============&gt;数组扩容失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是不是尾添加，是尾添加直接调用尾添加方法</span></span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;currentContainer == index) &#123;</span><br><span class="line">add(dynamicArray, e);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是不是头添加，是头添加直接调用头添加方法</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">addInHead(dynamicArray, e);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中间添加</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dynamicArray-&gt;currentContainer; i &gt; index; i--) &#123;</span><br><span class="line">(dynamicArray-&gt;p)[i] = (dynamicArray-&gt;p)[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">(dynamicArray-&gt;p)[index] = e;</span><br><span class="line">dynamicArray-&gt;currentContainer = dynamicArray-&gt;currentContainer + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addInHead</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头添加元素失败，失败原因===============&gt;参数不合法&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;currentContainer == dynamicArray-&gt;length &amp;&amp; FALSE == expandDynamicArray(dynamicArray)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头添加失败，失败原因=============&gt;动态数组扩容失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dynamicArray-&gt;currentContainer; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">(dynamicArray-&gt;p)[i] = (dynamicArray-&gt;p)[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">(dynamicArray-&gt;p)[<span class="number">0</span>] = e;</span><br><span class="line">dynamicArray-&gt;currentContainer = dynamicArray-&gt;currentContainer + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line">dynamicArray-&gt;currentContainer = <span class="number">0</span>;<span class="comment">//直接将当前数组置为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dynamicArray-&gt;currentContainer; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;动态数组第%d个位置的元素是============&gt;%d\n&quot;</span>, i, (dynamicArray-&gt;p)[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEle</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= dynamicArray-&gt;currentContainer || dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除动态数组中的元素失败，失败原因====================&gt;参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; dynamicArray-&gt;currentContainer - <span class="number">1</span>; i++) &#123;</span><br><span class="line">(dynamicArray-&gt;p)[i] = (dynamicArray-&gt;p)[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">dynamicArray-&gt;currentContainer = dynamicArray-&gt;currentContainer - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h3><p>当我们定义了文章开头的结构的时候，我们就是将这个结构体作为动态数组在使用</p><h4 id="扩容机制实现"><a href="#扩容机制实现" class="headerlink" title="扩容机制实现"></a>扩容机制实现</h4><p>当结构体中Container和I变量两个值相等的时候，那么当前结构体中p指针指向的数组就存储满了，那么就会调用malloc方法申请一块新的内存空间（每一个扩容都是在原来的容量上加10），并且使用for循环将原来p指针指向的数组中的数据拷贝到新的数组中，同时修改p指针的指向并且释放原来p指针指向的地址的内存空间</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><p>头添加时循环条件问题：int i = dynamicArray-&gt;currentContainer; i &gt; 0;i–，</p><ul><li><p>为啥int i = dynamicArray-&gt;currentContainer不是int i = dynamicArray-&gt;currentContainer-1？因为头添加的时候</p><p>数组需要将第一个元素空出来整体元素向后移动一个单位，int i = dynamicArray-&gt;currentContainer中的i就是移动过后最后一个元素的下标，如果是int i = dynamicArray-&gt;currentContainer-1那么就会丢失移动前的最后一个元素！！</p></li></ul></li><li><p>中间添加循环条件问题（既不是头添加，也不是尾添加）：int i = dynamicArray-&gt;currentContainer为什么不是int i = dynamicArray-&gt;currentContainer-1，因为int i = dynamicArray-&gt;currentContainer-1表示的是动态数组中已经添加的最后一个元素的下标，移动完毕后，int i = dynamicArray-&gt;currentContainer-1那么就会丢失移动前的最后一个元素！！</p></li></ul><h3 id="动态数组的优缺点"><a href="#动态数组的优缺点" class="headerlink" title="动态数组的优缺点"></a>动态数组的优缺点</h3><ul><li><p>优点</p><ul><li>能够动态的扩容，不存在把动态数组存储满了这一说法</li><li>依赖c语言中静态数组实现，在读写数据的时候根据下标进行查询，读写速度快</li></ul></li><li><p>缺点</p><ul><li>由于采用静态数组进行数据存储，当删除中间的元素的时候，会发生重新申请空间或者for循环移动数组次数太多的问，对于删除操作来说很慢</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态数组&quot;&gt;&lt;a href=&quot;#动态数组&quot; class=&quot;headerlink&quot; title=&quot;动态数组&quot;&gt;&lt;/a&gt;动态数组&lt;/h1&gt;&lt;p&gt;在c语言中我们都听过数组，创建一个数组也很简单，例如我们创建一个简单的数组&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="动态数组" scheme="https://i-fire.top/tags/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构简介</title>
    <link href="https://i-fire.top/post/datastructure.html"/>
    <id>https://i-fire.top/post/datastructure.html</id>
    <published>2020-11-14T11:03:08.000Z</published>
    <updated>2020-11-15T09:03:38.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/9663235">逻辑结构</a>和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构</p><p>数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782">存储结构</a></p><p>数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程</p><h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>指反映数据<a href="https://baike.baidu.com/item/%E5%85%83%E7%B4%A0">元素</a>之间的逻辑关系的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>，其中的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB">逻辑关系</a>是指数据元素之间的前后间关系，而与他们在计算机中的存储位置无关。逻辑结构包括</p><p>1.集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系</p><p>2.线性结构：数据结构中的元素存在一对一的相互关系</p><p>3.<a href="https://baike.baidu.com/item/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84">树形结构</a>：数据结构中的元素存在一对多的相互关系</p><p>4.<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84">图形结构</a>：数据结构中的元素存在多对多的相互关系</p><h3 id="数据的物理结构"><a href="#数据的物理结构" class="headerlink" title="数据的物理结构"></a>数据的物理结构</h3><p>指数据的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">逻辑结构</a>在计算机存储空间的存放形式</p><p>数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构</p><p>数据元素的机内表示（映像方法）： 用二进制位（bit）的位串表示数据元素。通常称这种位串为节点（node）。当数据元素有若干个数据项组成时，位串中与各个数据项对应的子位串称为数据域（data field）。因此，节点是数据元素的机内表示（或机内映像）</p><p>关系的机内表示（映像方法）：数据元素之间的关系的机内表示可以分为顺序映像和非顺序映像，常用两种存储结构：顺序存储结构和链式存储结构。顺序映像借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。非顺序映像借助指示元素存储位置的指针（pointer）来表示数据元素之间的逻辑关系</p><h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也称为存储结构)。一般来说，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等</p><p>数据的顺序存储结构的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>数据结构有很多种，一般来说，按照数据的逻辑结构对其进行简单的分类，包括线性结构和非线性结构两类</p><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>简单地说，线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：</p><p>1、线性结构是非空集</p><p>2、线性结构有且仅有一个开始结点和一个终端结点</p><p>3、线性结构所有结点都最多只有一个直接前趋结点和一个直接后继结点</p><p>线性表就是典型的线性结构，还有栈、队列和串等都属于线性结构</p><h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p>简单地说，非线性结构就是表中各个结点之间具有多个对应关系。如果从数据结构的语言来描述，非线性结构应该包括如下几点：</p><p>1、非线性结构是非空集</p><p>2、非线性结构的一个结点可能有多个直接前趋结点和多个直接后继结点</p><p>在实际应用中，数组、广义表、树结构和图结构等数据结构都属于非线性结构</p><h2 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h2><p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/9132">计算机科学</a>的发展过程中，数据结构也随之发展。程序设计中常用的数据结构包括如下几个</p><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p><a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097">数组</a>是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式</p><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈( Stack)"></a>栈( Stack)</h3><p><a href="https://baike.baidu.com/item/%E6%A0%88/12808149">栈</a>是一种特殊的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081">线性表</a>，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈</p><h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><p><a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481">队列</a>和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列</p><h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表( Linked List)"></a>链表( Linked List)</h3><p><a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473">链表</a>是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的</p><h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树( Tree)"></a>树( Tree)</h3><p><a href="https://baike.baidu.com/item/%E6%A0%91/2699484">树</a>是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0</p><h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h3><p><a href="https://baike.baidu.com/item/%E5%9B%BE/13018767">图</a>是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系</p><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p><a href="https://baike.baidu.com/item/%E5%A0%86/20606834">堆</a>是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构</p><h3 id="散列表-Hash"><a href="#散列表-Hash" class="headerlink" title="散列表(Hash)"></a>散列表(Hash)</h3><p>散列表源自于<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288">散列函数</a>(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录</p><hr><p><strong>注：以上内容来自<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fr=kg_qa">百度百科</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的&lt;a href=&quot;https://baike.bai</summary>
      
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>博客成立啦</title>
    <link href="https://i-fire.top/post/blogcreate.html"/>
    <id>https://i-fire.top/post/blogcreate.html</id>
    <published>2020-11-14T02:21:16.000Z</published>
    <updated>2020-11-15T09:00:04.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客成立啦"><a href="#博客成立啦" class="headerlink" title="博客成立啦"></a>博客成立啦</h1><p>当你看到这个页面，说明博客创建成功</p>]]></content>
    
    
    <summary type="html">博客成立</summary>
    
    
    
    <category term="大事记录" scheme="https://i-fire.top/categories/%E5%A4%A7%E4%BA%8B%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="生活" scheme="https://i-fire.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
